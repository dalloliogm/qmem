#!/usr/bin/php
<?php
/*
****************************************************************************
*                                                                          *
*                                QMEM  v0.1                                *
*                                                                          *
*                                           Author: Txema Heredia Genestar *
*                                                    txema.heredia@upf.edu *
*                                           Evolutionary Biology Institute *
*                                                               (UPF-CSIC) *
*                                                                          *
****************************************************************************

HOW TO USE IT:
In order to use qmem, your execution hosts must have configured "PER HOST" the following COMPLEX ATTIBUTES:
	h_vmem = set to the host total memory
	num_jobs = set to the host num of processors

You can exchange "num_jobs" by "slots" here in the code lines 75 and 76. We opted to use "num_jobs" instead of
"slots" because this allows us to submit jobs that override it and request 0 " If you want to stick to "slots", 
simply change it in lines 75 and 76.


Thanks:
Pablo: find color bug
Jaime: fixing color bug
Angel: Sorting properly qhost

Changes:
Work by default with slots variable instead of num_jobs
Prints host information (global and -u user information) one by one as they are generated instead of all at once at the end.
Fixed host name sorting conflicts with rocks-cluster
Added counter of running & suspended jobs at the end of output

Reads consumable variable local_disk
New parameter: -d

*/



// ARGUMENT PARSING

$param_jobs=false;
$param_disk=false;
$param_ok=true;

foreach ($argv as $param) {
	if ($param == $argv[0]) {
	} else if ($param == "-u") {
		$param_jobs=true;
	} else if ($param == "-d") {
		$param_disk=true;
	} else {
		$param_ok=false;
	}
}
if ( sizeof($argv) > 3 || !$param_ok ) {
	echo ("Usage:\n\tqmem\t[-u] [-d]\tShows the memory usage of all the cluster nodes.\n\t\t-u\t\tShows the memory usage of all the cluster nodes and all the jobs currently running in the cluster.\n\t\t-d\t\tShows the real local disk usage on all the cluster nodes and jobs.\n\tqmem -h\t\tShows this help.\n\n");
	exit(1);

}


// GET NODE LIST

$computes=null;
exec("qhost | grep -v \"\-\-\-\|global\|HOSTNAME\" | awk '{print $1}' | sort -t- +1 -2 +2 -3 -n",$res_comp);

$i =0;
foreach ($res_comp as $value) {
	$exec_nodes[$i] = $value;
	$i++;
}


$total_running=0;
$total_suspended=0;
$total_slots=0;


// OBTAIN EXECUTION HOST INFORMATION
//	H_VMEM value
//	NUM_JOBS value

for ($i=0; $i<sizeof($exec_nodes); $i++) {
	$mem = null;
	$disk = null;
	$jobs = null;
	$matchs=null;

	exec("qconf -se ".$exec_nodes[$i]." | sed 's/,/\\n/g' | grep h_vmem",$mem);
	
	if ( preg_match("/h_vmem=\d+(\.\d+){0,1}[TtGgMmKk]/", $mem[0], $matchs) ) {
		$mem=explode("=",$matchs[0]);
		$computes[$exec_nodes[$i]]['max']=$mem[1];
	} else {
		$computes[$exec_nodes[$i]]['max']="1K";
	}
	$computes[$exec_nodes[$i]]['used']=0;
	$computes[$exec_nodes[$i]]['reserved']=0;
	$computes[$exec_nodes[$i]]['used_disk']=0;
	$computes[$exec_nodes[$i]]['reserved_disk']=0;
	$computes[$exec_nodes[$i]]['jobs']=0;
	$computes[$exec_nodes[$i]]['df']=0;

	exec("qconf -se ".$exec_nodes[$i]." | sed 's/,/\\n/g' | grep slots",$jobs);
	if ( preg_match("/slots=\d+/", $jobs[0], $matchs) ) {
		$jobs=explode("=",$matchs[0]);
		$computes[$exec_nodes[$i]]['maxjobs']=$jobs[1];
	} else {
		$computes[$exec_nodes[$i]]['maxjobs']=0;
	}
	
	exec("qconf -se ".$exec_nodes[$i]." | sed 's/,/\\n/g' | grep local_disk",$disk);
	$matchs=null;
	if ( preg_match("/local_disk=\d+(\.\d+){0,1}[TtGgMmKk]/", $disk[0], $matchs) ) {
		$disk=explode("=",$matchs[0]);
		$computes[$exec_nodes[$i]]['diskmax']=$disk[1];
	} else {
		$computes[$exec_nodes[$i]]['diskmax']="1K";
	}
	if ($param_disk) {
		$df=null;
		exec(" ssh ".$exec_nodes[$i]." \"df -h | grep '\/tmp' | awk '{print \\$3}' \"",$df);
		$computes[$exec_nodes[$i]]['df']=$df[0];
	}

	$total_slots+=$computes[$exec_nodes[$i]]['maxjobs'];

}

// GET H_VMEM DEFAULT VALUE

exec("qconf -sc | grep h_vmem | awk '{print $7}'",$exec_default);
$default_mem = $exec_default[0];

$exec_default=null;
exec("qconf -sc | grep local_disk | awk '{print $7}'",$exec_default);
$default_disk = $exec_default[0];

// PRINT HEADER
if ($param_disk) {
	echo shell_exec("printf '\x1b\x5b0;39;49m\t\t\t\t\t\t\t\t\t\t Memory    Memory    Memory\t\t\t\t  Disk    Disk   Disk\n  Compute\t\t\t\tUsage\t\t\t   Percentage\tNeeeded   Reserved    Total\tSlots\t\t\t  Real  Reserved Total\x1b\x5b0;39;49m\n'");
} else {
	echo shell_exec("printf '\x1b\x5b0;39;49m\t\t\t\t\t\t\t\t\t\t Memory    Memory    Memory\t\t\t       Disk    Disk\n  Compute\t\t\t\tUsage\t\t\t   Percentage\tNeeeded   Reserved    Total\tSlots\t\t     Reserved  Total\x1b\x5b0;39;49m\n'");
}


// ITERATOR FOR EACH EXECUTION HOST

for ($i=0; $i<sizeof($exec_nodes); $i++) {


	// OBTAIN LIST OF JOBS RUNNING IN THAT NODE

	$llista_qstat=null;
	exec("qstat -u *, -s r -q *@".$exec_nodes[$i]."| grep -v \"\-\-\-\" | grep -v \"job-ID\" | sed 's/@/ /g' | sed 's/.local//g' | awk '{print $1\"\\t\"$9}' | sort -k2 | awk '{print $1\"@\"$2}'",$llista_qstat);
	$total_running+=sizeof($llista_qstat);

	// OBTAIN LIST OF JOBS ASSIGNED TO THAT NODE BUT CURRENTLY SUSPENDED

	$llista_suspended=null;
	exec("qstat -u *, -s s -q *@".$exec_nodes[$i]."| grep -v \"\-\-\-\" | grep -v \"job-ID\" | sed 's/@/ /g' | sed 's/.local//g' | awk '{print $1\"\\t\"$9}' | sort -k2 | awk '{print $1\"@\"$2}'",$llista_suspended);
	$total_running+=sizeof($llista_suspended);
	$total_suspended+=sizeof($llista_suspended);



	// FOR EACH RUNNING JOB IN THE NODE...

	foreach($llista_qstat as $job) {
	
		$exp=null;
		$exp=explode("@",$job);
	
		$comp=null;
		$jobid=null;

		$comp=$exec_nodes[$i];
		$jobid=$exp[0];

		// GET JOB INFO 	
		$exec_qstat=null;
		exec("qstat -j $jobid | grep 'hard resource_list\|owner\|maxvmem\|job_name'",$exec_qstat);

		// GET NUMBER OF SLOTS ASSIGNED
		$exec_slot=null;
		exec("qstat -u *, | grep $jobid | awk '{print $9}'",$exec_slot);
		$slot=1;
		$slot=$exec_slot[0];	

		$mem_job=null;
		$mem_job=$default_mem;
		$disk_job=null;
		$disk_job=$default_disk;
		$user = null;
		$maxvmem=null;
		$temps=null;
		$jobname=null;
		
		// PARSE JOB INFO
		if (sizeof($exec_qstat) > 0) {
			foreach ( $exec_qstat as $qstat ) {
				$matches=null;
				if ( preg_match("/local_disk=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$disk_job=$matches[1];
				}
				$matches=null;
				if ( preg_match("/h_vmem=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$mem_job=$matches[1];
				} else if ( preg_match("/owner:\s+(.+)/",$qstat,$matches) ) {
					$user=$matches[1];
				} else if ( preg_match("/maxvmem=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$maxvmem=$matches[1];
					$matches=null;
					preg_match("/cpu=([\d|:]+)/",$qstat,$matches);
					$temps=$matches[1];

				} else if ( preg_match("/job_name:\s+(.+)/",$qstat,$matches) ) {
					$jobname=$matches[1];
				}

			}
		}
		$du=null;
		if ($param_disk && $param_jobs) {
			exec(" ssh $comp \"du --max-depth=0 -h /tmp/*$jobid* | awk '{print \\$1}' \"",$du);
		}
		else {$du[0]="0";}

		// CONVERT MEMORY FROM BYTES TO A SEIZABLE UNIT
		$factor_reserved=factor_memoria($mem_job);	
		$factor_maxvmem=factor_memoria($maxvmem);	
		$factor_reserved_disk=factor_memoria($disk_job);	
		$factor_du=factor_memoria($du[0]);	


		// UPDATE THE COMPUTE USAGE WITH THE JOB INFORMATION
		$computes[$comp]['used']+=(substr($maxvmem,0,-1)*$factor_maxvmem);
		$computes[$comp]['reserved']+=(substr($mem_job,0,-1)*$factor_reserved*$slot);
		$computes[$comp]['reserved_disk']+=(substr($disk_job,0,-1)*$factor_reserved_disk*$slot);
		$computes[$comp]['jobs']+=$slot;
		$computes[$comp]['job_array'][$jobid]['user']=$user;
		$computes[$comp]['job_array'][$jobid]['jobname']=$jobname;
		$computes[$comp]['job_array'][$jobid]['status']="running";
		$computes[$comp]['job_array'][$jobid]['maxvmem']=(substr($maxvmem,0,-1)*$factor_maxvmem);
		$computes[$comp]['job_array'][$jobid]['reserved']=(substr($mem_job,0,-1)*$factor_reserved*$slot);
		$computes[$comp]['job_array'][$jobid]['reserved_disk']=(substr($disk_job,0,-1)*$factor_reserved_disk*$slot);
		$computes[$comp]['job_array'][$jobid]['time']=$temps;
		$computes[$comp]['job_array'][$jobid]['du']=(substr($du[0],0,-1)*$factor_du);
	

	}








	// FOR EACH SUSPENDED JOB IN THE EXECUTION HOST
	foreach($llista_suspended as $job) {
	
		$exp=null;
		$exp=explode("@",$job);
	
		$comp=null;
		$jobid=null;

		$comp=$exec_nodes[$i];

		$jobid=$exp[0];

		// GET JOB INFO	
		$exec_qstat=null;
		exec("qstat -j $jobid | grep 'hard resource_list\|owner\|maxvmem\|job_name'",$exec_qstat);

		// GET NUMBER OF SLOTS ASSIGNED
		$exec_slot=null;
		exec("qstat -u *, | grep $jobid | awk '{print $9}'",$exec_slot);
		$slot=1;
		$slot=$exec_slot[0];	

		$mem_job=null;
		$mem_job=$default_mem;
		$disk_job=null;
		$disk_job=$default_disk;
		$user = null;
		$maxvmem=null;
		$temps=null;
		$jobname=null;

		// PARSE JOB INFO
		if (sizeof($exec_qstat) > 0) {
			foreach ( $exec_qstat as $qstat ) {
				$matches=null;
				if ( preg_match("/local_disk=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$disk_job=$matches[1];
				}
				$matches=null;
				if ( preg_match("/h_vmem=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$mem_job=$matches[1];
				} else if ( preg_match("/owner:\s+(.+)/",$qstat,$matches) ) {
					$user=$matches[1];
				} else if ( preg_match("/maxvmem=([\d|.]+[KkMmGgTt]{0,1})/",$qstat,$matches) ) {
					$maxvmem=$matches[1];
					$matches=null;
					preg_match("/cpu=([\d|:]+)/",$qstat,$matches);
					$temps=$matches[1];
				} else if ( preg_match("/job_name:\s+(.+)/",$qstat,$matches) ) {
					$jobname=$matches[1];
				}

			}	
		}
		$du=null;
		if ($param_disk && $param_jobs) {
			exec(" ssh $comp \"du --max-depth=0 -h /tmp/*$jobid* | awk '{print \\$1}' \"",$du);
		}
		else {$du[0]="0";}


		// CONVERT MEMORY FROM BYTES TO A SEIZABLE UNIT
		$factor_reserved=factor_memoria($mem_job);	
		$factor_maxvmem=factor_memoria($maxvmem);	
		$factor_reserved_disk=factor_memoria($disk_job);	
		$factor_du=factor_memoria($du[0]);	


		// UPDATE THE COMPUTE USAGE WITH THE JOB INFORMATION
		$computes[$comp]['used']+=(substr($maxvmem,0,-1)*$factor_maxvmem);
		$computes[$comp]['reserved']+=(substr($mem_job,0,-1)*$factor_reserved*$slot);
		$computes[$comp]['reserved_disk']+=(substr($disk_job,0,-1)*$factor_reserved_disk*$slot);
		$computes[$comp]['jobs']+=$slot;
		$computes[$comp]['job_array'][$jobid]['user']=$user;
		$computes[$comp]['job_array'][$jobid]['jobname']=$jobname;
		$computes[$comp]['job_array'][$jobid]['status']="suspended";
		$computes[$comp]['job_array'][$jobid]['maxvmem']=(substr($maxvmem,0,-1)*$factor_maxvmem);
		$computes[$comp]['job_array'][$jobid]['reserved']=(substr($mem_job,0,-1)*$factor_reserved*$slot);
		$computes[$comp]['job_array'][$jobid]['reserved_disk']=(substr($disk_job,0,-1)*$factor_reserved_disk*$slot);
		$computes[$comp]['job_array'][$jobid]['time']=$temps;
		$computes[$comp]['job_array'][$jobid]['du']=(substr($du[0],0,-1)*$factor_du);

	}


// PRINTING
	$compute=null;
	$compute=$computes[$exec_nodes[$i]];
	$id = $exec_nodes[$i];





	$ratio_reserved = 0;
	$ratio_reserved = $compute['reserved']/substr($compute['max'],0,-1);
	$ratio_maxvmem = 0;
	$ratio_maxvmem = $compute['used']/substr($compute['max'],0,-1);
	$gastat = 0;
	$ocupat = 0;
	$lliure = 1;
	$long=50;

	$gastat = ceil($ratio_maxvmem*$long);
	$ocupat = ceil($ratio_reserved*$long)-$gastat;
	$lliure = $long-$ocupat-$gastat;
	
	$gastat_str="";
	for ($k = 0; $k<$gastat; $k++) {
		$gastat_str.="#";
	}

	$ocupat_str="";
	for ($k = 0; $k<$ocupat; $k++) {
		$ocupat_str.="#";
	}
	$lliure_str="";
	for ($k = 0; $k<$lliure; $k++) {
		$lliure_str.="#";
	}

	$percent=0;
	$percent=round($ratio_reserved*100,1);
	$color_percent=colorejar($percent,100);

	$percent=alinear($percent,5);



	$reserved=ajustar_memoria($compute['reserved']);
	$reserved=alinear($reserved,6);
	
	$used=ajustar_memoria($compute['used']);
	$used=alinear($used,6);
	
	$total=ajustar_memoria($compute['max']);
	$total=alinear($total,6);
	
	$max_jobs=$compute['maxjobs'];
	$color_jobs=colorejar($compute['jobs'], $max_jobs);
	
	$reserved_disk=ajustar_memoria($compute['reserved_disk']);
	$reserved_disk=alinear($reserved_disk,4);
	$df=alinear($compute['df'],6);
	$total_disk=ajustar_memoria($compute['diskmax']);
	$total_disk=alinear($total_disk,4);
	
	
	$cpu_ocupat_str="";
	for ($k = 0; $k<$compute['jobs']; $k++) {
		$cpu_ocupat_str.="#";
	}

	$cpu_lliure_str="";
	for ($k = 0; $k<($max_jobs-$compute['jobs']); $k++) {
		$cpu_lliure_str.="#";
	}


		
	// PRINT GLOBAL NODE INFO	
	if ($param_disk) {
		echo shell_exec("printf '\x1b\x5b0;39;49m$id:\t\x1b\x5b0;31;49m$gastat_str\x1b\x5b1;31;49m$ocupat_str\x1b\x5b1;32;49m$lliure_str$color_percent  $percent"." %% "."\t\x1b\x5b0;31;49m$used\x1b\x5b0;39;49m  / \x1b\x5b1;31;49m$reserved\x1b\x5b0;39;49m  / \x1b\x5b1;32;49m$total\t$color_jobs".$compute['jobs']."\x1b\x5b0;39;49m / ".$color_jobs.$max_jobs."\x1b\x5b0;39;49m (\x1b\x5b0;31;49m$cpu_ocupat_str\x1b\x5b1;32;49m$cpu_lliure_str\x1b\x5b0;39;49m)\t\x1b\x5b0;31;49m".$df."\x1b\x5b0;39;49m  / \x1b\x5b1;31;49m$reserved_disk\x1b\x5b0;39;49m / \x1b\x5b1;32;49m$total_disk\n'");
	} else {
		echo shell_exec("printf '\x1b\x5b0;39;49m$id:\t\x1b\x5b0;31;49m$gastat_str\x1b\x5b1;31;49m$ocupat_str\x1b\x5b1;32;49m$lliure_str$color_percent  $percent"." %% "."\t\x1b\x5b0;31;49m$used\x1b\x5b0;39;49m  / \x1b\x5b1;31;49m$reserved\x1b\x5b0;39;49m  / \x1b\x5b1;32;49m$total\t$color_jobs".$compute['jobs']."\x1b\x5b0;39;49m / ".$color_jobs.$max_jobs."\x1b\x5b0;39;49m (\x1b\x5b0;31;49m$cpu_ocupat_str\x1b\x5b1;32;49m$cpu_lliure_str\x1b\x5b0;39;49m)\t\x1b\x5b1;31;49m$reserved_disk\x1b\x5b0;39;49m / \x1b\x5b1;32;49m$total_disk\n'");
	}

	// IF -U ARGUMENT IS SET, PRINT JOB INFO
	if ($param_jobs && isset($compute['job_array']) && sizeof($compute['job_array'])>0 ) {
		$max_len_user=0;
		$max_len_name=0;
		$max_len_time=0;
		foreach ($compute['job_array'] as $jobid => $job) {
			if ( strlen($job['user']) > $max_len_user ) {
				$max_len_user=strlen($job['user']);
			}
			if ( strlen($job['jobname']) > $max_len_name ) {
				$max_len_name=strlen($job['jobname']);
			}
			if ( strlen($job['time']) > $max_len_time ) {
				$max_len_time=strlen($job['time']);
			}
		}
		foreach ($compute['job_array'] as $jobid => $job) {
			$user=alinear($job['user'],$max_len_user+3);
			
			$jobname=$job['jobname'];
		
			for ($ii=strlen($job['jobname']); $ii < $max_len_name; $ii++) {
				$jobname .= " ";
			}
			$temps=alinear($job['time'],$max_len_time);
			$maxvmem=alinear(ajustar_memoria($job['maxvmem']),9);
			$reserved=alinear(ajustar_memoria($job['reserved']),4);
			$percent=alinear(round(($job['maxvmem']/$job['reserved'])*100,1),5);
			
			$reserved_disk=alinear(ajustar_memoria($job['reserved_disk']),4);
	

			if ($param_disk) {
				$du=alinear(ajustar_memoria($job['du']),4);
				if ($job['status'] == "running") {
					$color_percent=colorejar_invers($percent,100);
				echo shell_exec("printf ' $color_percent$user\x1b\x5b0;39;49m\t$jobid\t$color_percent$percent %%\t$maxvmem\x1b\x5b0;39;49m  / $color_percent$reserved\x1b\x5b0;39;49m\t$jobname\t- $temps\t$du - $reserved_disk\n'");
				} else {
					$color_percent = "\x1b\x5b1;34;49m";
					echo shell_exec("printf ' $color_percent$user\t$jobid\t$percent %%\t$maxvmem  / $reserved\t$jobname\t- $temps\t$du - $reserved_disk\tSUSPENDED\n\x1b\x5b0;39;49m'");
				}
			} else {
				if ($job['status'] == "running") {
					$color_percent=colorejar_invers($percent,100);
				echo shell_exec("printf ' $color_percent$user\x1b\x5b0;39;49m\t$jobid\t$color_percent$percent %%\t$maxvmem\x1b\x5b0;39;49m  / $color_percent$reserved\x1b\x5b0;39;49m\t$jobname\t- $temps\t$reserved_disk\n'");
				} else {
					$color_percent = "\x1b\x5b1;34;49m";
					echo shell_exec("printf ' $color_percent$user\t$jobid\t$percent %%\t$maxvmem  / $reserved\t$jobname\t- $temps\t$reserved_disk\tSUSPENDED\n\x1b\x5b0;39;49m'");
				}
			}
		}
	}





}










$pending_array=null;
$mem_array=null;


// PRINT TAIL
$susp="";
if ($total_suspended>0) {
	$susp="[".$total_suspended." suspended] ";
}
echo shell_exec("printf '\n \x1b\x5b0;31;49m# \x1b\x5b0;39;49mMemory needed\n \x1b\x5b1;31;49m# \x1b\x5b0;39;49mMemory reserved\n \x1b\x5b1;32;49m# \x1b\x5b0;39;49mMemory available\n\n'");
echo ("(".$total_running." used slots ".$susp."out of ".$total_slots.")\n");



// RETURN COLOR ACCORDING TO A SCALE FROM RED TO PURPLE TO YELLOW TO GREEN
function colorejar($variable, $final) {
	$color = "\x1b\x5b0;39;49m";
	
	if ($variable >= 0.86*$final) {
		$color = "\x1b\x5b0;31;49m";
	} else if ( $variable >= 0.72*$final ) {
		$color = "\x1b\x5b1;31;49m";
	} else if ( $variable >= 0.58*$final ) {
		$color = "\x1b\x5b1;35;49m";
	} else if ( $variable >= 0.44*$final ) {
		$color = "\x1b\x5b1;33;49m";
	} else if ( $variable >= 0.30*$final ) {
		$color = "\x1b\x5b0;33;49m";
	} else if ( $variable >= 0.16*$final ) {
		$color = "\x1b\x5b1;32;49m";
	} else if ( $variable < 0.16*$final ) {
		$color = "\x1b\x5b0;32;49m";
 	}
	return $color;

}

// RETURN COLOR ACCORDING TO A SCALE FROM GREEN TO YELLOW TO PURPLE TO RED
function colorejar_invers($variable, $final) {
	$color = "\x1b\x5b0;39;49m";
	
	if ($variable >=0.86*$final ) {
		$color = "\x1b\x5b0;32;49m";
	} else if ( $variable >= 0.72*$final ) {
		$color = "\x1b\x5b1;32;49m";
	} else if ( $variable >= 0.58*$final ) {
		$color = "\x1b\x5b0;33;49m";
	} else if ( $variable >= 0.44*$final ) {
		$color = "\x1b\x5b1;33;49m";
	} else if ( $variable >= 0.3*$final ) {
		$color = "\x1b\x5b1;35;49m";
	} else if ( $variable >= 0.16*$final ) {
		$color = "\x1b\x5b1;31;49m";
	} else if ( $variable < 0.16*$final ) {
		$color = "\x1b\x5b0;31;49m";
 	}
	return $color;

}



// CONVERT MEMORY TO GIGABYTES
function factor_memoria ( $variable) {
	
	$factor=1;
	switch (substr($variable,-1)) {
		case 'k':
			$factor=1/(1024*1024);
			break;
		case 'K':
			$factor=1/(1024*1024);
			break;
		case 'm':
			$factor=1/(1024);
			break;
		case 'M':
			$factor=1/(1024);
			break;
		case 'g':
			$factor=1;
			break;
		case 'G':
			$factor=1;
			break;
		case 't':
			$factor=1024;
			break;
		case 'T':
			$factor=1024;
			break;
		default:
			$factor=1/(1024*1024);
			break;
	}
	return $factor;
}


// TRANSLATE BETWEEN MEMORY UNITS
function ajustar_memoria ($variable) {
	$variable_str="";
	if ($variable >= 1024) {
		$variable = $variable/1024;
		$variable_str = round($variable,1)."T";
} else if ($variable < 0.001 ) {
		$variable = $variable*1024*1024;
		$variable_str = round($variable,1)."K";
	} else if ($variable < 1 ) {
		$variable = $variable*1024;
		$variable_str = round($variable,1)."M";
	} else {
		$variable_str = round($variable,1)."G";
	}

	return $variable_str;

}

// ALIGN TEXT
function alinear ($variable, $long_max) {
	$var_str=$variable;
	for($i=strlen($var_str); $i <$long_max; $i++) {
		$var_str = " ".$var_str;
	}
	return $var_str;
	
}
?>
